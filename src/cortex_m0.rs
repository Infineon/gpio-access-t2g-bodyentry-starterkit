// \file cortex_m0.rs
// \copyright Copyright (C) Infineon Technologies AG 2023
// 
// Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
// business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
// are agreed, use of this file is subject to following:
// 
// Boost Software License - Version 1.0 - August 17th, 2003
// 
// Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
// accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
// and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
// Software is furnished to do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including the above license grant, this restriction
// and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
// derivative works of the Software, unless such copies or derivative works are solely in the form of
// machine-executable object code generated by a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
// COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ---

use panic_halt as _;
use cortex_m_rt::__RESET_VECTOR;
use cortex_m_semihosting::hprintln;
use cortex_m::delay::Delay;

use cyt2b7 as pac;
use pac::gpio as GPIO;
use pac::CPUSS;
use pac::SRSS;
use pac::SCB;

/// Executes before the main function and can be used for HW initialization.
///
/// 1. Sets up the interrupt vector tables for both the Cortex-M0+ (CM0) and
///    Cortex-M4 (CM4) CPU cores
/// 2. Enables the CM4 CPU core (TODO: Check the "ENABLED" status of CM4 first)
#[cortex_m_rt::pre_init]
unsafe fn before_main(){
    // Initialize the CM0 vector table address in the CM0P_SCS_VTOR register
    let vtor_addr = &(__RESET_VECTOR) as *const unsafe extern "C" fn() -> !;
    (*SCB::PTR).vtor.write(vtor_addr as u32 - 4);

    (*CPUSS::ptr()).cm4_clock_ctl.write(|w| w.fast_int_div().bits(0));
    (*CPUSS::ptr()).cm0_clock_ctl.write(|w| w.peri_int_div().bits(1));
    (*CPUSS::ptr()).cm0_clock_ctl.write(|w| w.slow_int_div().bits(0));

    (*SRSS::ptr()).clk_path_select[1].write(|w| w.path_mux().bits(0));
    (*SRSS::ptr()).clk_pll_config[0].write(|w| w.reference_div().bits(1));
    (*SRSS::ptr()).clk_pll_config[0].write(|w| w.feedback_div().bits(40));
    (*SRSS::ptr()).clk_pll_config[0].write(|w| w.output_div().bits(2));
    (*SRSS::ptr()).clk_pll_config[0].write(|w|  w.enable().bit(true));
    while (*SRSS::ptr()).clk_pll_status[0].read().locked().bit_is_clear() {}

    (*SRSS::ptr()).clk_path_select[2].write(|w| w.path_mux().bits(0));

    (*SRSS::ptr()).clk_root_select[0].write(|w| w.root_mux().bits(1));
    (*SRSS::ptr()).clk_root_select[0].write(|w| w.root_div().bits(0));
    (*SRSS::ptr()).clk_root_select[0].write(|w| w.enable().bit(true));

    (*SRSS::ptr()).clk_root_select[1].write(|w| w.root_mux().bits(1));
    (*SRSS::ptr()).clk_root_select[1].write(|w| w.root_div().bits(1));
    (*SRSS::ptr()).clk_root_select[1].write(|w| w.enable().bit(true));

    (*SRSS::ptr()).wdt.lock.write(|w| w.wdt_lock().bits(1));
    (*SRSS::ptr()).wdt.lock.write(|w| w.wdt_lock().bits(2));

    (*SRSS::ptr()).clk_ilo0_config.write(|w| w.enable().bit(true));
    (*SRSS::ptr()).clk_ilo0_config.write(|w| w.ilo0_backup().bit(true));

    (*SRSS::ptr()).wdt.ctl.write(|w| w.enable().bit(true));

    // Initialize the CM4 vector table in the CPUSS_CM4_VECTOR_TABLE_BASE register
    // with the start address of the vector table, which is at the beginning of the
    // FLASH assigned to the CM4 core (see the memory_cm4.x linker file).
    // This has to be done before starting the CM4 core.
    (*CPUSS::ptr())
        .cm4_vector_table_base
        .write(|w| w.bits(0x10008000));
    
    // Start the CM4 core
    (*CPUSS::ptr()).cm4_pwr_ctl.write(|w| w.bits(0x05fa0003) );
    _ = hprintln!("! CM0: before_main(): Harware initialization complete...");
}

/// CM0 "main" function
/// 
/// Demonstrates `unsafe` access to perihpheral registers.
/// The demo turns on LED1 (port 12, pin 2) by default and turns it off as
/// long as SW1 (port 7, pin 0) is kept pressed.
#[cortex_m_rt::entry]
fn main() -> ! {
    _ = hprintln!("! CM0: Entering main()...");

    // Core peripheral registers...
    let cp = cortex_m::Peripherals::take().unwrap();
    let syst = cp.SYST;
    
    let mut delay = Delay::new(syst, 80_000_000);
    let mut state = false;

    unsafe {
        let gpio = &*pac::GPIO::PTR;
                
        configure_led(gpio);
        configure_switch(gpio);



        loop {
/*                 if (*gpio).prt7.in_.read().in0().bit_is_clear() {
                    (*gpio).prt12.out_inv.write(|w| w.out2().bit(false));
                }
                else {
                    (*gpio).prt12.out_inv.write(|w| w.out2().bit(true));
                } */
            // Set GPIO state
            gpio.prt12.out_inv.write(|w| w.out2().bit(state));
            
            // Wait and toggle GPIO state
            delay.delay_ms(500);
            state = state^true;
        }
	}
}

/// Set-up the relevant GPIO port/pin for the LED
fn configure_led(gpio: *const GPIO::RegisterBlock) {
    let strong_value: u8 = GPIO::prt::cfg::DRIVE_MODE0_A::STRONG.into();
    unsafe {    
        (*gpio)
            .prt12
            .cfg
            .write(|w| w.drive_mode2().bits(strong_value));
    }
}

/// Set-up the relevant GPIO port/pin for the switch
fn configure_switch(gpio: *const GPIO::RegisterBlock) {
    let high_z_value: u8 = GPIO::prt::cfg::DRIVE_MODE0_A::HIGHZ.into();
    unsafe {
        (*gpio)
            .prt7
            .cfg
            .write(|w| { 
                w.drive_mode0().bits(high_z_value);
                w.in_en0().bit(true)
            });
        }
    }
