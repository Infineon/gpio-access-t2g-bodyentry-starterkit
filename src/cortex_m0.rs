// \file cortex_m0.rs
// \copyright Copyright (C) Infineon Technologies AG 2023
// 
// Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
// business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
// are agreed, use of this file is subject to following:
// 
// Boost Software License - Version 1.0 - August 17th, 2003
// 
// Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
// accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
// and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
// Software is furnished to do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including the above license grant, this restriction
// and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
// derivative works of the Software, unless such copies or derivative works are solely in the form of
// machine-executable object code generated by a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
// COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ---

use panic_halt as _;
use cortex_m_rt::__RESET_VECTOR;
use cortex_m::delay::Delay;
use cortex_m_semihosting::hprintln;

use cyt2b7 as pac;
use pac::gpio as GPIO;
use pac::SCB;

/// Executes before the main function and can be used for HW initialization
///
/// 1. Sets up the interrupt vector table Cortex-M0+ (CM0) core
/// 2. Initializes clocks
/// 3. Enables the Cortex-M4 (CM4) core
#[cortex_m_rt::pre_init]
unsafe fn before_main() {
    use crate::clock_init;
    use crate::enable_cm4;

    // Initialize the CM0 vector table address in the CM0P_SCS_VTOR register
    let vtor_addr = &(__RESET_VECTOR) as *const unsafe extern "C" fn() -> !;
    (*SCB::PTR).vtor.write(vtor_addr as u32 - 4);

    // Initialize clocks
    clock_init();

    // Enable the CM4 core
    enable_cm4();

    _ = hprintln!("! CM0: before_main(): Hardware initialization complete...");
}

/// CM0 "main" function
/// 
/// Demonstrates `unsafe` access to perihpheral registers.
/// The demo turns on LED1 (port 12, pin 2) by default and turns it off as
/// long as SW1 (port 7, pin 0) is kept pressed.
#[cortex_m_rt::entry]
fn main() -> ! {
    use crate::get_core_frequency;

    _ = hprintln!("! CM0: Entering main()...");

    // Core peripheral registers...
    let cp = cortex_m::Peripherals::take().unwrap();
    let syst = cp.SYST;

    let mut delay = Delay::new(syst, get_core_frequency());

    unsafe {
        let gpio = &*pac::GPIO::PTR;
                
        configure_led(gpio);
        configure_switch(gpio);

        loop {
            // Invert GPIO state once every 500ms
            gpio.prt12.out_inv.write(|w| w.out2().bit(true));
            delay.delay_ms(500);
        }
	}
}

/// Set-up the relevant GPIO port/pin for the LED
fn configure_led(gpio: *const GPIO::RegisterBlock) {
    let strong_value: u8 = GPIO::prt::cfg::DRIVE_MODE0_A::STRONG.into();
    unsafe {    
        (*gpio)
            .prt12
            .cfg
            .write(|w| w.drive_mode2().bits(strong_value));
    }
}

/// Set-up the relevant GPIO port/pin for the switch
fn configure_switch(gpio: *const GPIO::RegisterBlock) {
    let high_z_value: u8 = GPIO::prt::cfg::DRIVE_MODE0_A::HIGHZ.into();
    unsafe {
        (*gpio)
            .prt7
            .cfg
            .write(|w| { 
                w.drive_mode0().bits(high_z_value);
                w.in_en0().bit(true)
            });
    }
}
