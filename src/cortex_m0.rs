/**********************************************************************************************************************
 * \file cortex_m0.rs
 * \copyright Copyright (C) Infineon Technologies AG 2023
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

use cyt2b7 as pac;
use cortex_m::peripheral::NVIC;
use panic_halt as _;
use cortex_m_rt::__RESET_VECTOR;

use pac::gpio as GPIO;
use pac::CPUSS;
use pac::SCB;
use pac::interrupt;

/// Executed before the main function and does basic HW setup.
///
/// 1. Sets up the interrupt vector tables for both the Cortex-M0+ (CM0) and
///    Cortex-M4 (CM4) CPU cores
/// 2. Enables the CM4 CPU core (TODO: Check the "ENABLED" status of CM4 first)
#[cortex_m_rt::pre_init]
unsafe fn before_main(){
    // Initialize the CM0 vector table address in the CM0P_SCS_VTOR register
    let vtor_addr = &(__RESET_VECTOR) as *const unsafe extern "C" fn() -> !;
    (*SCB::PTR).vtor.write(vtor_addr as u32 - 4);

    // Initialize the CM4 vector table in the CPUSS_CM4_VECTOR_TABLE_BASE register
    // with the start address of the vector table, which is at the beginning of the
    // FLASH assigned to the CM4 core (see the memory_cm4.x linker file).
    // This has to be done before starting the CM4 core.
    (*CPUSS::ptr())
        .cm4_vector_table_base
        .write(|w|  w.bits(0x10008000) );
    
    // Start the CM4 core
    (*CPUSS::ptr()).cm4_pwr_ctl.write(|w|  w.bits(0x05fa0003) );  
}

#[cortex_m_rt::entry]
fn main() -> ! {
	unsafe{
        let p = &*pac::GPIO::PTR;

        let c =&*pac::CPUSS::PTR;
    
        //Interrupt related configuration
        (*c)
            .cm0_system_int_ctl[27]
            .write(|w|{ w.cpu_int_idx().bits(3) });
        (*c)
            .cm0_system_int_ctl[27]
            .write(|w|{ w.cpu_int_valid().bit(true) });


            NVIC::unmask(cyt2b7::Interrupt::CPUINT_IDX0);
                

        configure_led(p);
        configure_button(p);
        
        loop{   
                
                    
            }
	
	}
}


fn configure_led(p: *const GPIO::RegisterBlock) {
    let strong_value: u8 = GPIO::prt::cfg::DRIVE_MODE0_A::STRONG.into();
    unsafe {    
        (*p)
            .prt12
            .cfg
            .write(|w| w.drive_mode2().bits(strong_value));
    }
}

fn configure_button(p: *const GPIO::RegisterBlock) {
    let high_z_value: u8 = GPIO::prt::cfg::DRIVE_MODE0_A::HIGHZ.into();
    unsafe {
        (*p)
            .prt7
            .cfg
            .write(|w| { 
                w.drive_mode0().bits(high_z_value);
                w.in_en0().bit(true)
            });
        }
    
        let high_z_value: u8 = GPIO::prt::cfg::DRIVE_MODE0_A::HIGHZ.into();
		unsafe{
			
        (*p)
            .prt6
            .cfg
            .write(|w|{ w.drive_mode5().bits(high_z_value) });

        (*p)
            .prt6
            .cfg
            .write(|w|{ w.in_en5().bit(true)});

        (*p)
            .prt6
            .intr_cfg
            .write(|w|{ w.edge5_sel().bits(2)});
        (*p)
            .prt6
            .intr_mask
            .write(|w|{ w.edge5().bit(true)});
        (*p)
            .prt6
            .intr
            .write(|w|{ w.edge5().bit(false)});
		}
		
		
    }

#[interrupt]
fn CPUINT_IDX0() {
    //TODO : More checks to be added
    unsafe{
		let p =&*pac::GPIO::PTR;
        (*p)
            .prt6
            .intr
            .write(|w|{ w.edge5().bit(false)});
        (*p)
            .prt8.
            out_inv.write(|w| w.out2().bit(true));
       }
       NVIC::unpend(cyt2b7::Interrupt::CPUINT_IDX0);
}
