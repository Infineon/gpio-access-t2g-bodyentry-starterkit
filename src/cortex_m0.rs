// \file cortex_m0.rs
// \copyright Copyright (C) Infineon Technologies AG 2023
// 
// Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
// business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
// are agreed, use of this file is subject to following:
// 
// Boost Software License - Version 1.0 - August 17th, 2003
// 
// Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
// accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
// and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
// Software is furnished to do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including the above license grant, this restriction
// and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
// derivative works of the Software, unless such copies or derivative works are solely in the form of
// machine-executable object code generated by a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
// COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ---

use panic_halt as _;
use cortex_m_rt::__RESET_VECTOR;
use cortex_m_semihosting::hprintln;

use cyt2b7 as pac;
use pac::gpio as GPIO;
use pac::SCB;

/// Executes before the main function and can be used for HW initialization
///
/// 1. Sets up the interrupt vector table Cortex-M0+ (CM0) core
/// 2. Initializes clocks
/// 3. Enables the Cortex-M4 (CM4) core
#[cortex_m_rt::pre_init]
unsafe fn before_main() {
    use crate::config_sys_clk;
    use crate::enable_cm4;

    // Initialize the CM0 vector table address in the CM0P_SCS_VTOR register
    let vtor_addr = &(__RESET_VECTOR) as *const unsafe extern "C" fn() -> !;
    (*SCB::PTR).vtor.write(vtor_addr as u32 - 4);

    // Initialize clocks
    config_sys_clk();

    // Enable the CM4 core
    enable_cm4();

    _ = hprintln!("! CM0: before_main(): Hardware initialization complete...");
}

/// CM0 "main" function
/// 
/// Demonstrates `unsafe` access to perihpheral registers.
/// The demo turns on LED1 (port 12, pin 2) by default and turns it off as
/// long as SW1 (port 7, pin 0) is kept pressed.
#[cortex_m_rt::entry]
fn main() -> ! {
    _ = hprintln!("! CM0: Entering main()...");

    unsafe {
        let gpio = &*pac::GPIO::PTR;
                
        config_gpio(gpio);

        loop {
            if (*gpio).prt7.in_.read().in0().bit_is_clear() {
                (*gpio).prt12.out_clr.write(|w| w.out2().set_bit());
            }
            else {
                (*gpio).prt12.out_set.write(|w| w.out2().set_bit());
            }
        }
	}
}

/// Set-up the relevant GPIO port/pins for LED4 and SW1
fn config_gpio(gpio: *const GPIO::RegisterBlock) {
    let high_z_value: u8 = GPIO::prt::cfg::DRIVE_MODE0_A::HIGHZ.into();
    let strong_value: u8 = GPIO::prt::cfg::DRIVE_MODE0_A::STRONG.into();

    unsafe {    
        (*gpio).prt12.cfg.modify(|_, w| w.drive_mode2().bits(strong_value));

        (*gpio).prt7.cfg.modify(|_, w| w 
            .drive_mode0().bits(high_z_value)
            .in_en0().bit(true)
        );
    }
}
